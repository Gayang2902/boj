# Dynamic Programming
큰 문제를 작은 문제로 쪼개어 나가면서 문제를 해결하는 기법
### Top Down
큰 문제를 작은 문제로 쪼개어 나가면서 문제를 해결하는 방식
- 주로 재귀함수를 사용해 문제를 해결
구현은 쉽지만 재귀함수를 쓰기 때문에 느림
### Bottom Up
점화식으로 전체 알고리즘을 파악하여 작은 문제로 큰 문제를 해결
- 점화식을 찾기 힘들어 구현이 어려움
- 점화식을 찾으면 `for`문을 사용해 속도가 빠름

문제를 읽고 점화식을 빠르게 찾아낸다면 Bottom Up 형태로 문제를 풀면 되지만, 점화식을 찾는 것이 어려움
- Top Down 형태로 문제를 해결 -> Top Down 형태에서 찾아낸 점화식으로 Bottom Up으로 문제를 해결하는 것이 좋음

| 대표적인 DP 알고리즘: 피보나치 수열

### 메모이제이션 (Memoization)
DP에서 계산된 결과를 저장해두고 필요할 때 다시 사용하여 중복 계산을 피하는 기법

---
## 배낭 문제 (Knapsack Problem)
배낭 안에 물건을 채우는 방법에 대한 문제
- 가치가 다른 물건들을 잘 조합하여 최대의 가치를 가지게 만드는 문제

### 종류
1. 물건이 단 한 개씩밖에 없는 경우, 0-1 배낭 문제라 불리며 가장 대표적인 형태
2. 물건의 개수가 무한대인 경우. 허용된다면 물건을 몇 개를 넣어도 상관 없음
3. 물건이 여러 개 있는 경우. 물건의 개수가 정해져 있음
4. 물건을 쪼갤 수 있는 경우. 물건이 아니라 빵이나 액체류같이 원하는 무게로 나누어 가져갈 수 있는 경우

### 문제를 풀 수 있는 여러 방법
**Brute-Force** 
모든 경우의 수를 다 따져보는 것
- 문제를 해결할 수는 있지만, 속도가 매우 느림
**Greedy**
물건을 쪼개서 넣을 수 있는 경우, 그리디 방식으로 문제를 해결 가능
- 가장 무게가 많이 나가는 것을 순서대로 넣어주다가 마지막에 물건을 쪼개서 넣으면 됨
**DP**
각각의 물건을 넣을 때와 넣지 않았을 때를 생각
- 모든 경우의 수를 따지는 것이 아닌 가방에 넣을 수 있는 경우만을 따지기 때문에 브루트 포스보다는 경우의 수가 작음
